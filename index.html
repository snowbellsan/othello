<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ </title>
  <style>
    /* CSSéƒ¨åˆ†ã¯å¤‰æ›´ã‚ã‚Šã¾ã›ã‚“ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #1e7e34 0%, #28a745 50%, #20c997 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
    }

    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 1px, transparent 1px);
      background-size: 50px 50px;
      animation: moveGrid 20s linear infinite;
      z-index: 0;
    }

    @keyframes moveGrid {
      0% { transform: translate(0, 0); }
      100% { transform: translate(50px, 50px); }
    }

    .container {
      position: relative;
      z-index: 1;
      width: 100%;
      max-width: 500px;
      padding: 10px;
      max-height: 100vh;
      overflow-y: auto;
    }

    #titleScreen, #gameScreen {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
    }

    h1 {
      text-align: center;
      font-size: 2.5em;
      color: #1e7e34;
      margin-bottom: 20px;
      text-shadow: 3px 3px 6px rgba(0,0,0,0.1);
      animation: titlePulse 2s ease-in-out infinite;
    }

    @keyframes titlePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .settings-section {
      margin-bottom: 20px;
    }

    .settings-section label {
      display: block;
      font-size: 1.1em;
      font-weight: bold;
      margin-bottom: 10px;
      color: #333;
    }
    
    /* ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #difficultySelect {
        width: 100%;
        padding: 10px;
        font-size: 1em;
        border-radius: 8px;
        border: 2px solid #28a745;
        background-color: #f0fff0;
        cursor: pointer;
        appearance: none; 
        background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%2328a745"><path d="M7 10l5 5 5-5z"/></svg>');
        background-repeat: no-repeat;
        background-position: right 10px top 50%;
        background-size: 20px;
    }


    .hint-buttons {
      display: flex;
      flex-wrap: wrap; 
      gap: 8px;
    }

    .setting-btn {
      padding: 12px;
      font-size: 1em;
      font-weight: bold;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
      flex: 1 1 45%; 
    }

    .setting-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .setting-btn.selected {
      background: linear-gradient(135deg, #28a745, #20c997);
      color: white;
      transform: scale(1.02);
    }

    .setting-btn:not(.selected) {
      background: #e9ecef;
      color: #495057;
    }

    .start-btn {
      width: 100%;
      padding: 15px;
      font-size: 1.2em;
      font-weight: bold;
      background: linear-gradient(135deg, #007bff, #0056b3);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(0,123,255,0.4);
      margin-top: 15px;
    }

    .start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 6px 20px rgba(0,123,255,0.5);
    }

    .score-board {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding: 12px;
      background: linear-gradient(135deg, #f8f9fa, #e9ecef);
      border-radius: 15px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.1);
    }

    .player-score {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .stone-display {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      box-shadow: 0 3px 8px rgba(0,0,0,0.3);
      position: relative;
    }

    .stone-display.black {
      background: radial-gradient(circle at 30% 30%, #4a4a4a, #000);
    }

    .stone-display.white {
      background: radial-gradient(circle at 30% 30%, #fff, #ddd);
      border: 2px solid #999;
    }

    .score-number {
      font-size: 1.5em;
      font-weight: bold;
      color: #333;
      min-width: 40px;
      text-align: center;
    }

    .game-status {
      text-align: center;
    }

    .difficulty-display {
      font-size: 0.75em;
      color: #666;
      margin-bottom: 3px;
    }

    .turn-display {
      font-size: 1.1em;
      font-weight: bold;
      color: #1e7e34;
      min-height: 1.5em; 
    }

    .game-over {
      color: #7b1fa2;
      font-size: 1.2em;
    }

    .board-container {
      display: inline-block;
      background: linear-gradient(135deg, #2d5016, #1e7e34);
      padding: 10px;
      border-radius: 15px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.4), inset 0 2px 8px rgba(0,0,0,0.3);
    }

    .board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 1px;
      background: #1a5c28;
      border-radius: 8px;
      overflow: hidden;
    }

    .cell {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #2d7a3e, #238c41);
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      position: relative;
      transition: all 0.2s ease;
    }

    .cell:hover {
      background: linear-gradient(135deg, #3a8f4f, #2ea04d);
    }

    .stone {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      position: relative;
      box-shadow: 0 5px 12px rgba(0,0,0,0.4);
      animation: placeStone 0.3s ease-out;
    }

    .stone.black {
      background: radial-gradient(circle at 35% 35%, #4a4a4a, #000);
    }

    .stone.white {
      background: radial-gradient(circle at 35% 35%, #fff, #ddd);
      border: 2px solid #999;
    }

    .stone.flipping {
      animation: flipStone 0.4s ease-in-out;
    }

    @keyframes flipStone {
      0%, 100% { transform: rotateY(0deg); }
      50% { transform: rotateY(180deg); }
    }

    .valid-hint {
      width: 10px;
      height: 10px;
      background: radial-gradient(circle, #90ee90, #4caf50);
      border-radius: 50%;
      opacity: 0.7;
      animation: pulse 1.5s ease-in-out infinite;
      box-shadow: 0 0 8px rgba(76,175,80,0.6);
    }
    
    .hidden {
      display: none !important;
    }

    /* --- æ€è€ƒä¸­ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ --- */
    #thinkingOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6); 
        z-index: 1000; 
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .thinking-message-box {
        background: white;
        padding: 30px 50px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        text-align: center;
        font-size: 1.5em;
        font-weight: bold;
        color: #333;
    }

    /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ãƒ”ãƒŠãƒ¼ */
    .spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #28a745;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        animation: spin 1s linear infinite;
        margin: 10px auto 0;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }


    @media (max-width: 600px) {
      .cell { width: 45px; height: 45px; }
      .stone { width: 38px; height: 38px; }
    }

    @media (max-width: 400px) {
      .cell { width: 40px; height: 40px; }
      .stone { width: 34px; height: 34px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="titleScreen">
      <h1>ã‚ªã‚»ãƒ­ã‚²ãƒ¼ãƒ </h1>
      
      <div class="settings-section">
        <label for="difficultySelect">é›£æ˜“åº¦ã‚’é¸æŠ (ãƒ¬ãƒ™ãƒ«1ã€œ12)</label>
        <select id="difficultySelect">
          <option value="level1">ğŸ‘¶ ãƒ¬ãƒ™ãƒ«1 (ãƒ©ãƒ³ãƒ€ãƒ )</option>
          <option value="level2">ğŸŒ± ãƒ¬ãƒ™ãƒ«2 (ç²å¾—æ•°å„ªå…ˆ)</option>
          <option value="level3">ğŸŸ¢ ãƒ¬ãƒ™ãƒ«3 (å˜ç´”è©•ä¾¡)</option>
          <option value="level4">ğŸŸ¡ ãƒ¬ãƒ™ãƒ«4 (Depth 1)</option>
          <option value="level5">ğŸŸ  ãƒ¬ãƒ™ãƒ«5 (Depth 2)</option>
          <option value="level6">ğŸ”´ ãƒ¬ãƒ™ãƒ«6 (Depth 3)</option>
          <option value="level7">ğŸŸ£ ãƒ¬ãƒ™ãƒ«7 (Depth 4)</option>
          <option value="level8" selected>ğŸ‘‘ ãƒ¬ãƒ™ãƒ«8 (Depth 6/L8ãƒ™ãƒ¼ã‚¹)</option>
          <option value="level9">â­ ãƒ¬ãƒ™ãƒ«9 (Depth 6/å¢ƒç•ŒçŸ³)</option>
          <option value="level10">ğŸ”¥ ãƒ¬ãƒ™ãƒ«10 (Depth 7/å¢ƒç•ŒçŸ³å¼·åŒ–)</option>
          <option value="level11">âš”ï¸ ãƒ¬ãƒ™ãƒ«11 (Depth 7/å±é™ºãƒã‚¹å›é¿)</option>
          <option value="level12">ğŸ”® ãƒ¬ãƒ™ãƒ«12 (Depth 8/ç©¶æ¥µæˆ¦ç•¥)</option>
        </select>
      </div>

      <div class="settings-section">
        <label>ãƒ’ãƒ³ãƒˆè¡¨ç¤º</label>
        <div class="hint-buttons">
          <button class="setting-btn selected" data-hint="on">ğŸ’¡ ã‚ªãƒ³</button>
          <button class="setting-btn" data-hint="off">ğŸš« ã‚ªãƒ•</button>
        </div>
      </div>

      <button class="start-btn" onclick="startGame()">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
    </div>

    <div id="gameScreen" class="hidden">
      <div class="score-board">
        <div class="player-score">
          <div class="stone-display black"></div>
          <div class="score-number" id="blackScore">2</div>
        </div>
        <div class="game-status">
          <div class="difficulty-display" id="difficultyDisplay"></div>
          <div class="turn-display" id="turnDisplay">ã‚ãªãŸã®ç•ª</div>
          <div class="winner-display" id="winnerDisplay"></div>
        </div>
        <div class="player-score">
          <div class="score-number" id="whiteScore">2</div>
          <div class="stone-display white"></div>
        </div>
      </div>
      
      <div class="center">
        <div class="board-container">
          <div class="board" id="board"></div>
        </div>
      </div>

      <button class="back-btn" onclick="backToTitle()">ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹</button>
    </div>
  </div>

  <div id="noMovesOverlay" class="no-moves-overlay hidden">
    <div class="no-moves-message">
      ç½®ãã¨ã“ã‚ãŒ<br>ã‚ã‚Šã¾ã›ã‚“ï¼
    </div>
  </div>

  <div id="thinkingOverlay" class="hidden">
    <div class="thinking-message-box">
        <p>CPUãŒæ¬¡ã®æ‰‹ã‚’è€ƒãˆã¦ã„ã¾ã™...</p>
        <div class="spinner"></div>
    </div>
  </div>

  <script>
    let board = [];
    let currentPlayer = 'black';
    let difficulty = 'level8';
    let showHints = true;
    let gameOver = false;
    let flippingCells = new Set();
    let validMoves = [];

    // â˜…è¿½åŠ : æ€è€ƒæ™‚é–“ç®¡ç†ç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
    let searchStartTime;
    const TIME_LIMIT_MS = 3000; // 3ç§’ã«è¨­å®š
    let stopSearch = false; 

    const transpositionTable = new Map();
    const MAX_CACHE_SIZE = 100000;

    const directions = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1], [0, 1],
      [1, -1], [1, 0], [1, 1]
    ];
    
    const AI_CONFIGS = {
      'level1': { name: 'ğŸ‘¶ ãƒ¬ãƒ™ãƒ«1', strategy: 'random', depth: 0 },
      'level2': { name: 'ğŸŒ± ãƒ¬ãƒ™ãƒ«2', strategy: 'max_flips', depth: 0 },
      'level3': { name: 'ğŸŸ¢ ãƒ¬ãƒ™ãƒ«3', strategy: 'simple_eval', depth: 0 },
      'level4': { name: 'ğŸŸ¡ ãƒ¬ãƒ™ãƒ«4', strategy: 'minimax', depth: 1 },
      'level5': { name: 'ğŸŸ  ãƒ¬ãƒ™ãƒ«5', strategy: 'minimax', depth: 2 },
      'level6': { name: 'ğŸ”´ ãƒ¬ãƒ™ãƒ«6', strategy: 'minimax', depth: 3 },
      'level7': { name: 'ğŸŸ£ ãƒ¬ãƒ™ãƒ«7', strategy: 'minimax', depth: 4 }, 
      'level8': { name: 'ğŸ‘‘ ãƒ¬ãƒ™ãƒ«8', strategy: 'minimax', depth: 6 }, 
      'level9': { name: 'â­ ãƒ¬ãƒ™ãƒ«9', strategy: 'minimax', depth: 6 }, 
      'level10': { name: 'ğŸ”¥ ãƒ¬ãƒ™ãƒ«10', strategy: 'minimax', depth: 7 }, 
      'level11': { name: 'âš”ï¸ ãƒ¬ãƒ™ãƒ«11', strategy: 'minimax', depth: 7 }, 
      'level12': { name: 'ğŸ”® ãƒ¬ãƒ™ãƒ«12', strategy: 'minimax', depth: 8 } 
    };
    
    document.getElementById('difficultySelect').addEventListener('change', (e) => {
        difficulty = e.target.value;
    });

    document.querySelectorAll('.hint-buttons .setting-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.hint-buttons .setting-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        showHints = btn.dataset.hint === 'on';
      });
    });

    document.getElementById('noMovesOverlay').addEventListener('click', function() {
      this.classList.add('hidden');
    });

    function initBoard() {
      board = Array(8).fill(null).map(() => Array(8).fill(null));
      board[3][3] = 'white';
      board[3][4] = 'black';
      board[4][3] = 'black';
      board[4][4] = 'white';
    }

    function startGame() {
      difficulty = document.getElementById('difficultySelect').value;

      document.getElementById('titleScreen').classList.add('hidden');
      document.getElementById('gameScreen').classList.remove('hidden');
      document.getElementById('noMovesOverlay').classList.add('hidden');
      document.getElementById('thinkingOverlay').classList.add('hidden');
      
      transpositionTable.clear(); 
      
      document.getElementById('difficultyDisplay').textContent = AI_CONFIGS[difficulty].name;
      
      initBoard();
      currentPlayer = 'black';
      gameOver = false;
      flippingCells.clear();
      document.getElementById('winnerDisplay').textContent = '';
      document.getElementById('turnDisplay').classList.remove('game-over');
      renderBoard();
      calculateValidMoves('black');
      updateScores();
      updateTurnDisplay();
    }

    function backToTitle() {
      document.getElementById('gameScreen').classList.add('hidden');
      document.getElementById('titleScreen').classList.remove('hidden');
      document.getElementById('noMovesOverlay').classList.add('hidden');
      document.getElementById('thinkingOverlay').classList.add('hidden');
    }

    function renderBoard() {
      const boardEl = document.getElementById('board');
      boardEl.innerHTML = '';
      
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.row = i;
          cell.dataset.col = j;
          
          if (board[i][j]) {
            const stone = document.createElement('div');
            stone.className = 'stone ' + board[i][j];
            if (flippingCells.has(i + ',' + j)) {
              stone.classList.add('flipping');
            }
            cell.appendChild(stone);
          } else if (showHints && currentPlayer === 'black' && isValidMovePosition(i, j)) {
            const hint = document.createElement('div');
            hint.className = 'valid-hint';
            cell.appendChild(hint);
          }
          
          cell.addEventListener('click', () => handleCellClick(i, j));
          boardEl.appendChild(cell);
        }
      }
    }

    function isValidMove(row, col, player) {
      if (board[row][col] !== null) return [];
      
      const opponent = player === 'black' ? 'white' : 'black';
      const toFlip = [];

      for (const dir of directions) {
        const dx = dir[0];
        const dy = dir[1];
        const path = [];
        let x = row + dx;
        let y = col + dy;

        while (x >= 0 && x < 8 && y >= 0 && y < 8 && board[x][y] === opponent) {
          path.push([x, y]);
          x += dx;
          y += dy;
        }

        if (path.length > 0 && x >= 0 && x < 8 && y >= 0 && y < 8 && board[x][y] === player) {
          toFlip.push(...path);
        }
      }

      return toFlip;
    }

    function calculateValidMoves(player) {
      validMoves = [];
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (board[i][j] === null && isValidMove(i, j, player).length > 0) {
            validMoves.push([i, j]);
          }
        }
      }
      return validMoves;
    }

    function isValidMovePosition(row, col) {
      return validMoves.some(m => m[0] === row && m[1] === col);
    }

    function handleCellClick(row, col) {
      if (gameOver || currentPlayer === 'white') return;
      
      const toFlip = isValidMove(row, col, 'black');
      if (toFlip.length === 0) return;

      makeMove(row, col, toFlip, 'black');
    }

    function showNoMovesMessage() {
      document.getElementById('noMovesOverlay').classList.remove('hidden');
    }

    function makeMove(row, col, toFlip, player) {
      board[row][col] = player;
      
      flippingCells.clear();
      toFlip.forEach(pos => flippingCells.add(pos[0] + ',' + pos[1]));
      
      renderBoard();
      
      setTimeout(() => {
        toFlip.forEach(pos => {
          board[pos[0]][pos[1]] = player;
        });
        flippingCells.clear();
        renderBoard();
        updateScores();
        
        const nextPlayer = player === 'black' ? 'white' : 'black';
        const nextMoves = calculateValidMoves(nextPlayer);
        
        if (nextMoves.length === 0) {
          showNoMovesMessage();
          const backMoves = calculateValidMoves(player);
          if (backMoves.length === 0) {
            endGame();
          } else {
            // ãƒ‘ã‚¹ã—ã¦è‡ªåˆ†ã«æˆ»ã‚‹
            currentPlayer = player;
            updateTurnDisplay();
            if (currentPlayer === 'white') {
              setTimeout(() => makeAIMoveAsync(), 1500);
            }
          }
        } else {
          currentPlayer = nextPlayer;
          updateTurnDisplay();
          
          if (currentPlayer === 'white') {
            setTimeout(() => makeAIMoveAsync(), 500);
          }
        }
      }, 400);
    }

    // --- AI Move Logic (éåŒæœŸå‡¦ç†ã¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤åˆ¶å¾¡) ---
    function makeAIMoveAsync() {
        const turnEl = document.getElementById('turnDisplay');
        const thinkingOverlayEl = document.getElementById('thinkingOverlay');
        
        turnEl.textContent = 'CPUã®ç•ª';
        
        // æ€è€ƒé–‹å§‹ï¼šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¡¨ç¤º
        thinkingOverlayEl.classList.remove('hidden'); 

        setTimeout(() => {
            const bestMove = makeAIMove();
            
            // å‡¦ç†å¾Œã€ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’éè¡¨ç¤ºã«æˆ»ã™
            thinkingOverlayEl.classList.add('hidden');

            if (bestMove) {
                makeMove(bestMove.row, bestMove.col, bestMove.flips, 'white');
            } else {
                const backMoves = calculateValidMoves('black');
                if (backMoves.length === 0) {
                    endGame();
                } else {
                    currentPlayer = 'black';
                    updateTurnDisplay();
                }
            }
        }, 10); 
    }

    // â˜…ä¿®æ­£: makeAIMoveã«åå¾©æ·±åŒ–ã¨æ™‚é–“åˆ¶é™ã‚’å°å…¥
    function makeAIMove() {
      const config = AI_CONFIGS[difficulty];
      const moves = [];
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const toFlip = isValidMove(i, j, 'white');
          if (toFlip.length > 0) {
            moves.push({ row: i, col: j, flips: toFlip });
          }
        }
      }

      if (moves.length === 0) return null;

      let bestMove = moves[0];

      if (config.strategy === 'random') {
        bestMove = moves[Math.floor(Math.random() * moves.length)];
      } else if (config.strategy === 'max_flips') {
        bestMove = moves.reduce((best, move) => 
          move.flips.length > (best.flips ? best.flips.length : -1) ? move : best
        , moves[0]);
      } else if (config.strategy === 'simple_eval') {
        bestMove = moves.reduce((best, move) => {
          const testBoard = applyMoveToBoard(board, move.row, move.col, move.flips, 'white');
          const score = evaluateBoard(testBoard);
          return score > (best.score || -Infinity) ? { ...move, score } : best;
        }, {});
      } else if (config.strategy === 'minimax') {
        
        let emptyCells = 0;
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if (board[i][j] === null) {
              emptyCells++;
            }
          }
        }

        // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆæ·±åº¦ã‚’å‹•çš„ã«è¨­å®š
        let targetDepth = config.depth; 
        if (difficulty === 'level12' && emptyCells > 20) {
            targetDepth = 7; 
        }

        searchStartTime = Date.now();
        stopSearch = false;
        let finalBestMove = bestMove;
        let finalMaxScore = -Infinity;

        // æ‰‹ã®äº‹å‰ã‚½ãƒ¼ãƒˆ (ã‚¯ã‚¤ãƒƒã‚¯è©•ä¾¡) ã¯æœ€åˆã«ä¸€åº¦ã ã‘å®Ÿè¡Œ
        moves.forEach(move => {
            const newBoard = applyMoveToBoard(board, move.row, move.col, move.flips, 'white');
            move.quickEval = evaluateBoardQuick(newBoard); 
        });
        moves.sort((a, b) => b.quickEval - a.quickEval);

        // åå¾©æ·±åŒ–æ¢ç´¢ãƒ«ãƒ¼ãƒ—
        for (let depth = 1; depth <= targetDepth; depth++) {
            if (stopSearch) break; 

            let currentMaxScore = -Infinity;
            let currentBestMove = null;
            
            for (const move of moves) {
                if (stopSearch) break; // æ™‚é–“åˆ‡ã‚Œãƒã‚§ãƒƒã‚¯
                
                const newBoard = applyMoveToBoard(board, move.row, move.col, move.flips, 'white');
                // æ¢ç´¢æ·±ã•ã‚’ current depth - 1 ã§å‘¼ã³å‡ºã—
                const score = minimax(newBoard, depth - 1, false, -Infinity, Infinity); 

                if (score > currentMaxScore) {
                    currentMaxScore = score;
                    currentBestMove = move;
                }
            }

            if (!stopSearch && currentBestMove) {
                // ãã®æ·±åº¦ã®æ¢ç´¢ã‚’æ™‚é–“å†…ã«å®Œäº†ã—ãŸå ´åˆã€æœ€å–„æ‰‹ã‚’æ›´æ–°
                finalMaxScore = currentMaxScore;
                finalBestMove = currentBestMove;
            } else if (stopSearch) {
                // æ™‚é–“åˆ‡ã‚Œã®å ´åˆã€ç›´å‰ã®æ·±åº¦ã®çµæœã‚’ä¿æŒã—ã¦ãƒ«ãƒ¼ãƒ—ã‚’çµ‚äº†
                break;
            }
        }
        return finalBestMove;
      }
      return bestMove;
    }

    function boardToHash(testBoard) {
        return testBoard.map(row => row.map(cell => cell === null ? '.' : cell[0]).join('')).join('');
    }

    function evaluateBoardQuick(testBoard) {
        const baseWeights = [
            [500, -20, 10, 5, 5, 10, -20, 500],
            [-20, -50, -2, -2, -2, -2, -50, -20],
            [10, -2, 5, 1, 1, 5, -2, 10],
            [5, -2, 1, 0, 0, 1, -2, 5],
            [5, -2, 1, 0, 0, 1, -2, 5],
            [10, -2, 5, 1, 1, 5, -2, 10],
            [-20, -50, -2, -2, -2, -2, -50, -20],
            [500, -20, 10, 5, 5, 10, -20, 500]
        ];

        let score = 0;
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                if (testBoard[i][j] === 'white') {
                    score += baseWeights[i][j];
                } else if (testBoard[i][j] === 'black') {
                    score -= baseWeights[i][j];
                }
            }
        }
        return score; 
    }

    // â˜…ä¿®æ­£: minimaxé–¢æ•°ã«æ™‚é–“åˆ‡ã‚Œãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
    function minimax(currentBoard, depth, isMaximizingPlayer, alpha = -Infinity, beta = Infinity) {
      
      if (Date.now() - searchStartTime > TIME_LIMIT_MS) {
          stopSearch = true;
          return isMaximizingPlayer ? alpha : beta; // æ™‚é–“åˆ‡ã‚Œã®å ´åˆã¯ç›´ã¡ã«æ¢ç´¢ã‚’æ‰“ã¡åˆ‡ã‚‹
      }
      
      const player = isMaximizingPlayer ? 'white' : 'black';
      const opponent = isMaximizingPlayer ? 'black' : 'white';

      // ãƒˆãƒ©ãƒ³ã‚¹ãƒã‚¸ã‚·ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«ã®ãƒã‚§ãƒƒã‚¯
      const boardHash = boardToHash(currentBoard);
      const cacheKey = `${boardHash}-${depth}-${isMaximizingPlayer}`;
      if (transpositionTable.has(cacheKey)) {
        return transpositionTable.get(cacheKey);
      }

      if (depth === 0) {
        const score = evaluateBoard(currentBoard);
        if (transpositionTable.size < MAX_CACHE_SIZE) {
          transpositionTable.set(cacheKey, score);
        }
        return score;
      }
      
      const moves = calculateValidMovesAtDepth(currentBoard, player);

      if (moves.length === 0) {
        const opponentMovesExist = calculateValidMovesAtDepth(currentBoard, opponent).length > 0;
        
        if (!opponentMovesExist) {
            let black = 0; let white = 0;
            for(let i=0; i<8; i++) { for(let j=0; j<8; j++) { 
                if (currentBoard[i][j] === 'black') black++;
                if (currentBoard[i][j] === 'white') white++;
            }}
            return (white - black) * 100000; 
        }

        return minimax(currentBoard, depth, !isMaximizingPlayer, alpha, beta);
      }

      // æ‰‹ã‚’ç°¡æ˜“è©•ä¾¡å€¤ã§ã‚½ãƒ¼ãƒˆ
      moves.forEach(move => {
        const newBoard = applyMoveToBoard(currentBoard, move.row, move.col, move.flips, player);
        move.quickEval = evaluateBoardQuick(newBoard);
      });
      
      if (isMaximizingPlayer) {
        moves.sort((a, b) => b.quickEval - a.quickEval);
      } else {
        moves.sort((a, b) => a.quickEval - b.quickEval);
      }

      if (isMaximizingPlayer) {
        let maxScore = -Infinity;
        for (const move of moves) {
          const newBoard = applyMoveToBoard(currentBoard, move.row, move.col, move.flips, player);
          const score = minimax(newBoard, depth - 1, false, alpha, beta);
          
          if (stopSearch) return maxScore; // æ‰“ã¡åˆ‡ã‚Šå¾Œã®æˆ»ã‚Šå€¤å‡¦ç†

          maxScore = Math.max(maxScore, score);
          
          alpha = Math.max(alpha, maxScore);
          if (beta <= alpha) {
            break; 
          }
        }
        if (transpositionTable.size < MAX_CACHE_SIZE) {
          transpositionTable.set(cacheKey, maxScore);
        }
        return maxScore;
      } else {
        let minScore = Infinity;
        for (const move of moves) {
          const newBoard = applyMoveToBoard(currentBoard, move.row, move.col, move.flips, player);
          const score = minimax(newBoard, depth - 1, true, alpha, beta);
          
          if (stopSearch) return minScore; // æ‰“ã¡åˆ‡ã‚Šå¾Œã®æˆ»ã‚Šå€¤å‡¦ç†

          minScore = Math.min(minScore, score);
          
          beta = Math.min(beta, minScore);
          if (beta <= alpha) {
            break; 
          }
        }
        if (transpositionTable.size < MAX_CACHE_SIZE) {
          transpositionTable.set(cacheKey, minScore);
        }
        return minScore;
      }
    }

    function applyMoveToBoard(currentBoard, row, col, flips, player) {
      const newBoard = currentBoard.map(r => [...r]);
      newBoard[row][col] = player;
      flips.forEach(pos => {
        newBoard[pos[0]][pos[1]] = player;
      });
      return newBoard;
    }

    function isValidMoveAtDepth(testBoard, row, col, player) {
      if (testBoard[row][col] !== null) return [];
      
      const opponent = player === 'black' ? 'white' : 'black';
      const toFlip = [];

      for (const dir of directions) {
        const dx = dir[0];
        const dy = dir[1];
        const path = [];
        let x = row + dx;
        let y = col + dy;

        while (x >= 0 && x < 8 && y >= 0 && y < 8 && testBoard[x][y] === opponent) {
          path.push([x, y]);
          x += dx;
          y += dy;
        }

        if (path.length > 0 && x >= 0 && x < 8 && y >= 0 && y < 8 && testBoard[x][y] === player) {
          toFlip.push(...path);
        }
      }

      return toFlip;
    }

    function calculateValidMovesAtDepth(testBoard, player) {
        const moves = [];
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                const flips = isValidMoveAtDepth(testBoard, i, j, player);
                if (testBoard[i][j] === null && flips.length > 0) {
                    moves.push({ row: i, col: j, flips: flips });
                }
            }
        }
        return moves;
    }

    function calculateFronterStonesAtDepth(testBoard, player) {
        let fronterCount = 0;
        for (let i = 0; i < 8; i++) {
            for (let j = 0; j < 8; j++) {
                if (testBoard[i][j] === player) {
                    for (const dir of directions) {
                        const ni = i + dir[0];
                        const nj = j + dir[1];
                        if (ni >= 0 && ni < 8 && nj >= 0 && nj < 8 && testBoard[ni][nj] === null) {
                            fronterCount++;
                            break; 
                        }
                    }
                }
            }
        }
        return fronterCount;
    }

    function isStable(testBoard, row, col, player) {
        if (testBoard[row][col] !== player) return false;
        
        const corners = [[0, 0], [0, 7], [7, 0], [7, 7]];
        const isCorner = corners.some(c => c[0] === row && c[1] === col);

        if (isCorner) {
            let stableCount = 0;
            const checks = [
                [0, 1], [0, -1],
                [1, 0], [-1, 0]
            ];
            
            for (const [dr, dc] of checks) {
                let r = row + dr, c = col + dc;
                let isLineStable = true;
                while (r >= 0 && r < 8 && c >= 0 && c < 8) {
                    if (testBoard[r][c] !== player) {
                        isLineStable = false;
                        break;
                    }
                    r += dr;
                    c += dc;
                }
                if (isLineStable) stableCount++;
            }
            return stableCount >= 2;
        }
        return false;
    }

    function evaluateBoard(testBoard) {
      let baseWeights = [
        [500, -20, 10, 5, 5, 10, -20, 500],
        [-20, -50, -2, -2, -2, -2, -50, -20],
        [10, -2, 5, 1, 1, 5, -2, 10],
        [5, -2, 1, 0, 0, 1, -2, 5],
        [5, -2, 1, 0, 0, 1, -2, 5],
        [10, -2, 5, 1, 1, 5, -2, 10],
        [-20, -50, -2, -2, -2, -2, -50, -20],
        [500, -20, 10, 5, 5, 10, -20, 500]
      ];
      
      const level = difficulty;
      let finalWeights = baseWeights.map(arr => [...arr]); 

      if (level === 'level11' || level === 'level12') {
          const penalty = level === 'level12' ? -200 : -100;
          
          finalWeights[1][2] += penalty; finalWeights[1][5] += penalty;
          finalWeights[6][2] += penalty; finalWeights[6][5] += penalty;

          finalWeights[0][1] += penalty * 0.5; finalWeights[1][0] += penalty * 0.5;
          finalWeights[0][6] += penalty * 0.5; finalWeights[1][7] += penalty * 0.5;
          finalWeights[7][1] += penalty * 0.5; finalWeights[6][0] += penalty * 0.5;
          finalWeights[7][6] += penalty * 0.5; finalWeights[6][7] += penalty * 0.5;
      }

      let score = 0;
      let emptyCells = 0;
      let whiteCount = 0;
      let blackCount = 0;
      let whiteStable = 0;
      let blackStable = 0;

      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (testBoard[i][j] === 'white') {
            score += finalWeights[i][j];
            whiteCount++;
            if (isStable(testBoard, i, j, 'white')) whiteStable++;
          } else if (testBoard[i][j] === 'black') {
            score -= finalWeights[i][j];
            blackCount++;
            if (isStable(testBoard, i, j, 'black')) blackStable++;
          } else {
            emptyCells++;
          }
        }
      }
      
      const whiteMoves = calculateValidMovesAtDepth(testBoard, 'white').length;
      const blackMoves = calculateValidMovesAtDepth(testBoard, 'black').length;

      const mobilityWeight = (level === 'level12') ? 100 : 50; 
      const mobilityScore = (whiteMoves - blackMoves) * mobilityWeight;
      score += mobilityScore;
      
      const stableWeight = (level === 'level12') ? 2000 : 1000;
      const stableScore = (whiteStable - blackStable) * stableWeight;
      score += stableScore;

      if (level === 'level9' || level === 'level10' || level === 'level11' || level === 'level12') {
          const whiteFronter = calculateFronterStonesAtDepth(testBoard, 'white');
          const blackFronter = calculateFronterStonesAtDepth(testBoard, 'black');
          
          let fronterWeight = 100;
          if (level === 'level10' || level === 'level11') fronterWeight = 200;
          if (level === 'level12') fronterWeight = 500;

          const fronterScore = (blackFronter - whiteFronter) * fronterWeight;
          score += fronterScore;
      }

      if (emptyCells <= 10) {
        const finalWeight = (level === 'level12') ? 10000 : 5000; 
        const diff = whiteCount - blackCount;
        score += diff * finalWeight;
      }
      
      return score;
    }

    function updateScores() {
      let black = 0;
      let white = 0;
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (board[i][j] === 'black') black++;
          if (board[i][j] === 'white') white++;
        }
      }
      document.getElementById('blackScore').textContent = black;
      document.getElementById('whiteScore').textContent = white;
      
      if (black + white === 64 || black === 0 || white === 0) {
        endGame();
      }
    }

    function updateTurnDisplay() {
      const turnEl = document.getElementById('turnDisplay');
      document.getElementById('thinkingOverlay').classList.add('hidden'); 
      turnEl.textContent = currentPlayer === 'black' ? 'ã‚ãªãŸã®ç•ª' : 'CPUã®ç•ª';
      renderBoard();
    }

    function endGame() {
      gameOver = true;
      const black = parseInt(document.getElementById('blackScore').textContent);
      const white = parseInt(document.getElementById('whiteScore').textContent);
      
      const turnEl = document.getElementById('turnDisplay');
      document.getElementById('thinkingOverlay').classList.add('hidden');
      
      turnEl.textContent = 'ã‚²ãƒ¼ãƒ çµ‚äº†ï¼';
      turnEl.classList.add('game-over');
      
      const winnerEl = document.getElementById('winnerDisplay');
      if (black > white) {
        winnerEl.textContent = 'ğŸ‰ ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ã‚ãªãŸã®å‹ã¡ã§ã™ï¼';
      } else if (white > black) {
        winnerEl.textContent = 'ğŸ’« CPUã®å‹ã¡ã§ã™ï¼';
      } else {
        winnerEl.textContent = 'ğŸ¤ å¼•ãåˆ†ã‘ï¼';
      }
    }
  </script>
</body>
</html>